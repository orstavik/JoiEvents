<script type="module">
  //rule #1: event objects cannot be reused. Override dispatchEvent() to clone all events that has propagated before.
  //rule #2: all events propagate sync. No more async propagation for UI events. Which is good, because you can never
  //         tell if an event is async or sync.
  //rule #3: all adding of event listeners are dynamic.
  //         No more special rule that event listeners on the same target(phase) can be removed, but not added.
  //rule #4: all at_target event listeners now run capture before bubble. No more special rule that innermost target
  //         shuffle all capture and bubble event listeners in one common insertion order.

  //tip 1:   all event listeners are removed when the event stack is empty.

  function getPropagationRoot(el) {
    const root = el.getRootNode && el.getRootNode() || window;//todo should the window be separated as its own document?
    return root === document ? window : root;
  }

  function makeBouncedPath(composedPath) {
    const docs = [];
    for (let el of composedPath) {
      const root = getPropagationRoot(el);
      const doc = docs.find(({root: oldRoot}) => oldRoot === root);
      doc ?                   //first encounter
        doc.nodes.push(el) :
        el instanceof HTMLSlotElement ?
          docs.push({root, nodes: [el]}) :
          docs.unshift({root, nodes: [el]});
    }
    return docs;
  }

  //todo turn this into a generator? yes, i must try:)
  export class EventFrame {
    constructor(event) {
      this.event = event;
      this.bouncedPath = makeBouncedPath(event.composedPath());
      this.doc = 0;
      this.phase = 0;
      this.target = 0;
      this.listener = -1;
      Object.defineProperties(event, {
        'currentTarget': {
          get: function () {
            debugger;
            return this.currentDocument && this.currentDocument[this.target];
          }
        },
        'eventPhase': {
          get: function () {
            debugger;
            return this.phase ? 3 : 1
          }
        },
        'currentDocument': {
          get: function () {
            debugger;
            return this.bouncedPath[this.doc]?.root;
          }
        },
        'path': {
          get: function () {
            debugger;
            return this.currentDocument?.nodes;
          }
        },
        'bouncedPath': {
          get: function () {
            debugger;
            return this.bouncedPath;
          }
        }
      });

    }

    next() {
      this.listener++;
      for (; this.doc < this.bouncedPath.length; this.doc++) {
        const {root, nodes: targets} = this.bouncedPath[this.doc];
        for (; this.phase < 2; this.phase++) {
          for (; this.target < targets.length; this.target++) {
            const elCapBub = this.phase ? this.target : targets.length - 1 - this.target;
            const target = targets[elCapBub];
            const listenerEntries = target[listeners];
            if (listenerEntries) {
              for (; this.listener < listenerEntries.length; this.listener++) {
                const listener = listenerEntries[this.listener];
                if (listener.type === this.event.type && listener.capture ^ this.phase)
                  return listener;
              }
            }
            this.listener = 0;
          }
          this.target = 0;
        }
        this.phase = 0;
      }
    }
  }

  const spentEvents = new WeakSet();
  const listeners = Symbol("listeners");
  const removedListeners = [];
  const eventStack = [];

  const dispatchEventOG = EventTarget.prototype.dispatchEvent;
  EventTarget.prototype.dispatchEvent = function (e) {
    if (spentEvents.has(e)) {
      const clone = new Event(e);
      Object.assign(clone, e);
      e = clone;
    }
    dispatchEventOG.call(this, e);
  }

  function eventTick(e) {
    if (spentEvents.has(e))
      return;
    spentEvents.add(e);

    const frame = new EventFrame(e);
    eventStack.unshift(frame);

    for (let listener; listener = frame.next();) {
      listener.once && removedListeners.push(listener);
      listener.cb.call(listener.target, e);
    }
    if (frame !== eventStack.shift()) throw 'omg';
    eventStack.length === 0 && removedListeners.forEach(removeListenerImpl);
  }

  function getListener(target, type, cb, capture) {
    target[listeners] || (target[listeners] = []);
    return target[listeners].find(old => old.type === type && old.cb === cb && old.capture === capture && !old.removed);
  }

  function defaultPassiveValue(type, target) {
    return (type === 'touchstart' || type === 'touchmove') && (target === window || target === document || target === body);
  }

  function addListenerImpl(l) {
    l.target[listeners].push(l);
    addEventListenerOG.call(l.target, l.type, l.realCb, {capture: l.capture, passive: l.passive});
  }

  function removeListenerImpl(l) {
    l.target[listeners].splice(l.target[listeners].indexOf(l), 1);
    removeEventListenerOG.call(l.target, l.type, l.realCb, {capture: l.capture, passive: l.passive});
  }

  const addEventListenerOG = EventTarget.prototype.addEventListener;
  EventTarget.prototype.addEventListener = function (type, cb, options) {
    // if(!(cb instanceof Function))
    //   return;//fail silently?
    const capture = options instanceof Object ? options.capture : !!options;
    if (getListener(this, type, cb, capture))
      return;
    const target = this;
    const passive = options instanceof Object && 'passive' in options ? options.passive : defaultPassiveValue(type, target);
    const once = options instanceof Object && 'once' in options && options.once;
    const listener = {target, type, cb, capture, passive, once};
    listener.realCb = eventTick.bind(listener); //we don't use the listener object, but we need to bind the eventTick to something to get a unique realCb.
    addListenerImpl(listener);
  }

  const removeEventListenerOG = EventTarget.prototype.removeEventListener;
  EventTarget.prototype.removeEventListener = function (type, cb, options) {
    const capture = options instanceof Object ? options.capture : !!options;
    const listener = getListener(this, type, cb, capture);
    listener && (listener.removed = true) && removedListeners.push(listener);
  }
</script>

<div>
  <link-slot>
    <span>
      <outer-host></outer-host>
    </span>
    <h2>hello world</h2>
  </link-slot>
</div>

<script type="module">

  class OuterHost extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({mode: "open"});
      this.shadowRoot.innerHTML = '<link-slot><inner-host></inner-host></link-slot>';
    }
  }

  class InnerHost extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({mode: "open"});
      this.shadowRoot.innerHTML = '<h1>hello sunshine</h1>';
    }
  }

  class LinkSlot extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({mode: "open"});
      this.shadowRoot.innerHTML = '<frame-slot><slot></slot></frame-slot>';
    }
  }

  class FrameSlot extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({mode: "open"});
      this.shadowRoot.innerHTML = '<slot></slot>';
    }
  }

  customElements.define("outer-host", OuterHost);
  customElements.define("inner-host", InnerHost);
  customElements.define("link-slot", LinkSlot);
  customElements.define("frame-slot", FrameSlot);

  const outerHost = document.querySelector("outer-host");
  const h1 = outerHost.shadowRoot.children[0].children[0].shadowRoot.children[0];
  h1.addEventListener('alice', e => {
    for (let node of e.composedPath()) {
      let root = node.getRootNode ? node.getRootNode() : node;
      root = root.host ? root.host.nodeName + '#shadow' : root.nodeName || 'window';
      node.addEventListener('bob', e => console.log(root, 'capture', node.nodeName || 'window'), true);
      node.addEventListener('bob', e => console.log(root, 'bubble', node.nodeName || 'window'));
    }
    console.log("setting up");
  }, {once: true});
  h1.dispatchEvent(new Event('alice', {composed: true, bubbles: true}));
  h1.dispatchEvent(new Event('bob', {composed: true, bubbles: true}));
</script>