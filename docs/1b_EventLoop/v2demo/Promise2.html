<h1>hello sunshine</h1>

<script>

  (async function () {

    function parseNextTickArg(cbs) {
      if (cbs instanceof Function)
        return [cbs];
      if (cbs instanceof Array && cbs.length && cbs.every(fun => fun instanceof Function))
        return cbs.slice();    //avoids external mutations
      throw new Error("only a Function, an array of functions can be passed to nextTick");
    }

    function  runMesoLevelTask(e) {
      if (!this._mesoLevelTasks)                        //the macrotask has been cancelled
        e.stopImmediatePropagation();
      else
        this._mesoLevelTasks.shift()();
    }

    function addMesoLevelTasks(cbs, level) {
      var resolveCb;
      var promise = new Promise(function (resolve) { //todo implement reject here
        resolveCb = function mesoStepComplete() {    //todo i don't think the method should ever reject. I don't think it can.
          resolve(true);
        };
      });
      cbs.push(resolveCb);
      level._mesoLevelTasks = cbs;                   //todo life is nice!!
      for (let i = 0; i < level._mesoLevelTasks.length; i++) {
        level.addEventListener("ratechange", runMesoLevelTask.bind(level), true);
      }
      return promise;
    }

    //levels: starts as [ audio, span ]
    //        grows when needed into [ audio, span , span , ... , span ]
    var levels = [document.createElement("audio"), document.createElement("span")];
    levels[1].appendChild(levels[0]);

    function getClone(depth) {
      if (depth < levels.length)
        return levels[depth].cloneNode(true);
      var span;
      for (let i = 0; i < (depth - levels.length + 1); i++) {
        span = document.createElement("span");
        span.appendChild(levels[levels.length - 1]);
        levels.push(span);
      }
      return span.cloneNode(true);
    }

    function getTopAudio(depth) {
      var top = getClone(depth);
      var el = top;
      while (el.children.length)
        el = el.children[0];
      return [top, el];
    }

    function ratechangeTickStart(cbs, mesoLevels) {
      var topAudio = getTopAudio(mesoLevels);
      topAudio[1].playbackRate = 2;
      return topAudio[0];
    }

    window.nextTick = function (cbs, mesoLevels) {
      mesoLevels = Math.max(parseInt(mesoLevels), 0);
      cbs = parseNextTickArg(cbs);
      var level = ratechangeTickStart(cbs, mesoLevels);
      var macrotaskPromise = addMesoLevelTasks(cbs, level);
      macrotaskPromise.nextMesoTick = function (cbs2) {
        level = level.children[0];              //todo working on a closure variable.. its safe for interference, but not from developer error..
        if (!level)                             //todo should i add "levels" to the macrotaskPromise instead??
          throw new Error("cannot add any more mesotasks to this macrotask");
        cbs2 = parseNextTickArg(cbs2);
        return addMesoLevelTasks(cbs2, level);
      };
      // to flush a macroTask, you call cancel() which returns an array of not yet done methods,
      //                       and then you call these returned functions.
      //returns an array with the functions that were cancelled
      //todo should we implement a method that has a selective cancellation? no... that seems overly functional..
      macrotaskPromise.cancel = function () {
        var undone = [];
        var uncalledResolvers = [];
        //start with level, it is the deepest one that has added mesotasks
        while (level && level._mesoLevelTasks && level._mesoLevelTasks.length) {
          uncalledResolvers.push(level._mesoLevelTasks.pop());//take out the listener that will call the resolve on the element.
          undone = level._mesoLevelTasks.concat(undone);      //take the rest of the listeners out into undone
          level._mesoLevelTasks = undefined;                  //set to undefined to communicate the method being removed.
          level = level.parentNode;
        }
        for (let i = 0; i < uncalledResolvers.length; i++) {
          let uncalledResolver = uncalledResolvers[i];
          uncalledResolver();
        }
        return undone;
      };
      return macrotaskPromise;
    }
  })();
</script>

<script>
  (async function () {
    function one() {
      console.log("one");
    }

    function two() {
      console.log("two");
    }

    const task = nextTick([one, two], 2);
    console.log("a")
    const res1 = await task;                        //the result here is just true, it would be better to have the result from the methods.
    console.log("a")
    const res2 = await task.nextMesoTick([two]);    //the result here is just true, it would be better to have the result from the methods.
    console.log("a")
    const res3 = await task.nextMesoTick([two]);    //the result here is just true, it would be better to have the result from the methods.
    console.log("a")
  })();

  setTimeout(async function () {
    function three() {
      console.log("three");
    }

    function four() {
      console.log("four");
    }

    const task = nextTick([three, four], 1);
    console.log("b")
    const res1 = await task;                        //the result here is just true, it would be better to have the result from the methods.
    console.log("b")
    const res2 = await task.nextMesoTick([four]);    //the result here is just true, it would be better to have the result from the methods.
    console.log("b")
    const res3 = await task.nextMesoTick([four]);    //the result here is just true, it would be better to have the result from the methods.
    console.log("b")
  }, 100);

  setTimeout(async function () {
    function five() {
      console.log("five");
    }

    function six() {
      console.log("six");
    }

    const task = nextTick([five, six], 1);
    await task;
    task.nextMesoTick(five);
    const cancelled = task.cancel();
    for (let cb of cancelled) {
      cb();
    }

  }, 200);

</script>