<h1>hello sunshine</h1>

<script>

  (async function () {

    function parseNextTickArg(cbs) {
      if (!cbs)
        return [];
      if (cbs instanceof Function)
        return [cbs];
      if (cbs instanceof Array)
        return cbs.slice();    //avoids external mutations
      throw new Error("only a Function, an array of functions, or falsy can be added to nextTick");
    }

    function addMesoLevelTasks(cbs, level) {
      var resolveCb;
      var promise = new Promise(function (resolve) { //todo implement reject here
        resolveCb = function mesoStepComplete() {    //todo i don't think the method should ever reject. I don't think it can.
          resolve(true);
        };
      });
      //todo wrap all the cbs in a function that removes it?, or simply add {once: true}
      //todo but then I get no register of it, so I would not know if it was run or not.
      //
      cbs.push(resolveCb);
      // level._mesoLevelTasks = cbs; //todo life is nice!!
      for (let i = 0; i < cbs.length; i++)
        level.addEventListener("ratechange", cbs[i], true);
        // level.addEventListener("ratechange", cbs[i], {capture: true, once: true}
      return promise;
    }

    //levels: starts as [ audio, span ]
    //        grows when needed into [ audio, span , span , ... , span ]
    var levels = [document.createElement("audio"), document.createElement("span")];
    levels[1].appendChild(levels[0]);

    function getClone(depth) {
      if (depth < levels.length)
        return levels[depth].cloneNode(true);
      var span;
      for (let i = 0; i < (depth - levels.length + 1); i++) {
        span = document.createElement("span");
        span.appendChild(levels[levels.length - 1]);
        levels.push(span);
      }
      return span.cloneNode(true);
    }

    function getTopAudio(depth) {
      var top = getClone(depth);
      var el = top;
      while (el.children.length)
        el = el.children[0];
      return [top, el];
    }

    function ratechangeTickStart(cbs, mesoLevels) {
      var topAudio = getTopAudio(mesoLevels);
      topAudio[1].playbackRate = 2;
      return topAudio[0];
    }

    window.nextTick = function (cbs, mesoLevels) {
      mesoLevels = Math.max(parseInt(mesoLevels), 0);
      cbs = parseNextTickArg(cbs);
      var level = ratechangeTickStart(cbs, mesoLevels);
      var macrotaskPromise = addMesoLevelTasks(cbs, level);
      macrotaskPromise.nextMesoTick = function (cbs2) {
        level = level.children[0];              //todo working on a closure variable.. its safe for interference, but not from developer error..
        if (!level)                             //todo should i add "levels" to the macrotaskPromise instead??
          throw new Error("cannot add any more mesotasks to this macrotask");
        return addMesoLevelTasks(cbs2, level);
      };
      macrotaskPromise.cancel = function (cb) {
        //todo ok, so if we have the register of event listeners, and the once is updated to update this register,
        //todo then we could simply ask for the event register callbacks, and then return that to the user from cancel().
        //todo if cb is nothing, then cancel everything.
        //todo if cb is a function, cancel that function
        //todo if cb is an array of functions, then cancel those functions.

        //todo to flush the macroTask, you call cancel() which returns an array of not yet done methods, and then you call these returned functions.
      };
      return macrotaskPromise;
    }
  })();
</script>

<script>
  (async function () {
    function one() {
      console.log("one");
    }

    function two() {
      console.log("two");
    }

    const task = nextTick([one, two], 2);
    console.log("a")
    const res1 = await task;                        //the result here is just true, it would be better to have the result from the methods.
    console.log("a")
    const res2 = await task.nextMesoTick([two]);    //the result here is just true, it would be better to have the result from the methods.
    console.log("a")
    const res3 = await task.nextMesoTick([two]);    //the result here is just true, it would be better to have the result from the methods.
    console.log("a")
  })();

  setTimeout(async function () {
    function three() {
      console.log("three");
    }

    function four() {
      console.log("four");
    }

    const task = nextTick([three, four], 1);
    console.log("b")
    const res1 = await task;                        //the result here is just true, it would be better to have the result from the methods.
    console.log("b")
    const res2 = await task.nextMesoTick([four]);    //the result here is just true, it would be better to have the result from the methods.
    console.log("b")
    const res3 = await task.nextMesoTick([four]);    //the result here is just true, it would be better to have the result from the methods.
    console.log("b")
  }, 100);

</script>