<script>
  function compareResults(expect, res, nativeRes, notFirst) {
    res = (res === expect ? 1 : res + " != " + expect);
    if (notFirst && res === nativeRes)
      res = res === 1 ? null : undefined;
    return res;
  }

  function nextTick2(cb) {
    let r;
    const p = new Promise(function (resolve) {
      r = resolve;
    });
    setTimeout(function () {
      cb();
      setTimeout(function () {
        r();
      })//todo i need setTimeout(..., 1) for this to work in ff?
    }); //todo i need 1 for this to work in ff?
    return p;
  }

  async function runTests(eventSystems, tests) {
    const results = {};
    let nativeSysName = eventSystems[0].sysname;
    for (let test of tests)
      results[test.name] = {};
    for (let {sysname, upgrade, downgrade} of eventSystems) {
      await nextTick2(upgrade);
      for (const {name, fun, expect, result} of tests) {
        await nextTick2(fun);
        await nextTick2(function () {
          const res = result();
          const expected = expect instanceof Function ? expect() : expect;
          const nativeRes = results[name][nativeSysName];
          results[name][sysname] = compareResults(expected, res, nativeRes, sysname !== nativeSysName);
        });
      }
      await nextTick2(downgrade);
    }
    return nextTick2(function () {
      console.table(results);
    });
  }
</script>

<script type="module">
  import {
    addEventTargetRegistry as addEventTargetRegistry1,
    getEventListeners as getEventListeners1
  } from "./getEventListeners.js";
  import {
    addEventTargetRegistry as addEventTargetRegistry2,
    getEventListeners as getEventListeners2
  } from "./getEventListeners_once.js";
  import {
    addEventTargetRegistry as addEventTargetRegistry3,
    getEventListeners as getEventListeners3
  } from "./getEventListeners_once_last.js";
  import {addEventTargetRegistry, getEventListeners} from "./getEventListeners_once_last_first.js";
  import {addEventIsStoppedScoped, addEventListenerOptionScopedUnstoppable, isStopped} from "./ScopedEventListeners.js";
  import {addDispatchEventOptionAsync} from "./dispatchEventOptionAsync.js";
  import {scopedPaths} from "./computePaths.js";

  const addEventListenerOG = EventTarget.prototype.addEventListener;
  const removeEventListenerOG = EventTarget.prototype.removeEventListener;
  const dispatchEventOG = EventTarget.prototype.dispatchEvent;
  const stopPropOG = Event.prototype.stopPropagation;
  const stopImmediateOG = Event.prototype.stopImmediatePropagation;
  const cancelBubbleOG = Object.getOwnPropertyDescriptor(Event.prototype, "cancelBubble");

  function downgrade() {
    EventTarget.prototype.addEventListener = addEventListenerOG;
    EventTarget.prototype.removeEventListener = removeEventListenerOG;
    EventTarget.prototype.dispatchEvent = dispatchEventOG;
    Event.prototype.stopPropagation = stopPropOG;
    Event.prototype.stopImmediatePropagation = stopImmediateOG;
    Object.defineProperty(Event.prototype, "cancelBubble", cancelBubbleOG);
    window.getEventListeners = function () {
      return [];
    };
    window.isStopped = function (event, scoped) {
      return event.cancelBubble;
    };
    window.scopedPaths = function (element, composed) {
      return [];
    };
  }

  downgrade();

  const eventSystems = [{
    sysname: "NATIVE",
    upgrade: function () {
    },
    downgrade: function () {
    },
  }, {
    sysname: "SCOPED_STOP",
    upgrade: function () {
      addEventIsStoppedScoped(Event.prototype);
      addEventListenerOptionScopedUnstoppable(EventTarget.prototype)
      window.isStopped = isStopped;
    },
    downgrade: downgrade,
    // }, { //todo
    //   sysname: "SCOPED_STOP_BY_DEFAULT",
    //   upgrade: function () {
    //     addEventIsStoppedScoped(Event.prototype);
    //     addEventListenerOptionScopedUnstoppable(EventTarget.prototype)
    //     window.isStopped = isStopped;
    //     Object.defineProperty(Event.prototype, "isScoped", {value: true});
    //   },
    //   downgrade: function(){
    //     downgrade();
    //     Object.defineProperty(Event.prototype, "isScoped", {value: undefined});
    //   }
  }, {
    sysname: "REGISTER",
    upgrade: function () {
      addEventTargetRegistry1(EventTarget.prototype);
      window.getEventListeners = getEventListeners1;
    },
    downgrade: downgrade,
  }, {
    sysname: "scopedPaths",
    upgrade: function () {
      window.scopedPaths = scopedPaths;
    },
    downgrade: downgrade,
  }, {
    sysname: "REGISTER_once",
    upgrade: function () {
      addEventTargetRegistry2(EventTarget.prototype);
      window.getEventListeners = getEventListeners2;
    },
    downgrade: downgrade,
  }, {
    sysname: "REGISTER_once_last",
    upgrade: function () {
      addEventTargetRegistry3(EventTarget.prototype);
      window.getEventListeners = getEventListeners3;
    },
    downgrade: downgrade,
  }, {
    sysname: "REGISTER_once_last_first",
    upgrade: function () {
      addEventTargetRegistry(EventTarget.prototype);
      window.getEventListeners = getEventListeners;
    },
    downgrade: downgrade,
  }, {
    sysname: "SCOPED_STOP+REGISTER_once_last_first",
    upgrade: function () {
      addEventIsStoppedScoped(Event.prototype);
      addEventListenerOptionScopedUnstoppable(EventTarget.prototype)
      window.isStopped = isStopped;
      // addEventListenerOptionUnstoppable(EventTarget.prototype, Event.prototype);
      addEventTargetRegistry(EventTarget.prototype);
      window.getEventListeners = getEventListeners;
    },
    downgrade: downgrade,
  }, {
    sysname: "DISPATCH_ASYNC+REGISTER_once_last_first",
    upgrade: function () {
      addEventTargetRegistry(EventTarget.prototype);
      addDispatchEventOptionAsync(EventTarget.prototype)
      window.getEventListeners = getEventListeners;
    },
    downgrade: downgrade,
  }];

  import {testBasic} from "./unitTests/testBasic.js";
  import {dynamicTest} from "./unitTests/testDynamic.js";
  import {testRegistry} from "./unitTests/testRegistry.js";
  import {testOnce} from "./unitTests/testOnce.js";
  import {testUnstoppable, cancelBubbleTests} from "./unitTests/testUnstoppable.js";
  import {lastTest, lastErrorsTest, last2} from "./unitTests/testLast.js";
  import {firstTest, firstErrorsTest, first2} from "./unitTests/testFirst.js";
  import {testProp} from "./unitTests/testPropagation.js";
  import {testStopProp, testStopProp2} from "./unitTests/testStopPropagation.js";
  import {testIsStopped} from "./unitTests/testIsStopped.js";
  import {testScopedPaths, testComposedPath} from "./unitTests/testPaths.js";
  import {basicPropTest} from "./unitTests/testPropagationBasic.js";

  (async function () {
    await runTests(eventSystems, testBasic);
    await runTests(eventSystems, dynamicTest);
    await runTests(eventSystems, testRegistry);
    await runTests(eventSystems, testOnce);
    await runTests(eventSystems, testUnstoppable);
    await runTests(eventSystems, cancelBubbleTests);
    await runTests(eventSystems, lastTest);
    await runTests(eventSystems, last2);
    await runTests(eventSystems, lastErrorsTest);
    await runTests(eventSystems, firstTest);
    await runTests(eventSystems, first2);
    await runTests(eventSystems, firstErrorsTest);
    await runTests(eventSystems, testStopProp);
    await runTests(eventSystems, testStopProp2);
    await runTests(eventSystems, testIsStopped);
    await runTests(eventSystems, testProp);
    await runTests(eventSystems, testScopedPaths);
    await runTests(eventSystems, testComposedPath);
    await runTests(eventSystems, basicPropTest);
  })();
  //todo
  // 1. test stopPropagation thoroughly
  // 2. perform the same check outside in the dispatchEvent loop as is done inside in the scopedStop wrappers.
  //this is redundant.. we could have a wrapper method for that one..
</script>