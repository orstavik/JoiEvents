<script>

  const addEventListenerOG = EventTarget.prototype.addEventListener;
  const removeEventListenerOG = EventTarget.prototype.removeEventListener;
  const dispatchEventOG = EventTarget.prototype.dispatchEvent;
  const stopPropOG = Event.prototype.stopPropagation;
  const stopImmediateOG = Event.prototype.stopImmediatePropagation;
  const cancelBubbleOG = Object.getOwnPropertyDescriptor(Event.prototype, "cancelBubble");

  function resetSystem() {
    EventTarget.prototype.addEventListener = addEventListenerOG;
    EventTarget.prototype.removeEventListener = removeEventListenerOG;
    EventTarget.prototype.dispatchEvent = dispatchEventOG;
    Event.prototype.stopPropagation = stopPropOG;
    Event.prototype.stopImmediatePropagation = stopImmediateOG;
    Object.defineProperty(Event.prototype, "cancelBubble", cancelBubbleOG);
    window.getEventListeners = function () {
      return [];
    };
    window.isStopped = function (event, scoped) {
      return event.cancelBubble;
    };
    window.scopedPaths = function (element, composed) {
      return [];
    };
  }

  function nextTick2(cb) {
    let r;
    const p = new Promise(function (resolve) {
      r = resolve;
    });
    setTimeout(function () {
      cb();
      setTimeout(function () {
        r();
      })//todo i need setTimeout(..., 1) for this to work in ff?
    }); //todo i need 1 for this to work in ff?
    return p;
  }

  function setValue(obj, a, b, value) {
    !obj[a] && (obj[a] = {});
    !obj[a][b] && (obj[a][b] = {});
    obj[a][b] = value;
  }

  //first i upgrade.
  //then i make the usecase
  //then i pass the usecase to the test.
  //this means that the test gets a usecase.
  //this is a dom branch presented as a manually defined scopedPath

  function printResults(results) {
    for (let [testName, testResults] of Object.entries(results)) {
      const expected = testResults.expected;
      delete testResults.expected;
      const native = testResults.NATIVE;
      for (let [systemName, result] of Object.entries(testResults)) {
        if (systemName === "NATIVE")
          testResults[systemName] = result === expected ? 1 : result;
        else
          testResults[systemName] =
            (result === expected && result === native) ? null :
              (result === expected) ? 1 :
                (result === native) ? undefined :
                  result;
      }
    }
    console.table(results);
  }

  async function runTests(eventSystems, tests, usecases) {
    usecases = usecases || [{name: undefined}];
    const results = {};
    for (let system of eventSystems) {
      await nextTick2(system);                //todo do we need async here?? i think not??
      for (const {name: testName, fun, expect} of tests) {
        for (let usecase of usecases) {

          const expected = expect instanceof Function ? expect(usecase) : expect;
          setValue(results, testName + ":" + usecase.name, "expected", expected);

          let result = [];
          await nextTick2(function () {
            fun(result, usecase);
          });
          await nextTick2(function () {
            setValue(results, testName + ":" + usecase.name, system.name, result.join(""));
          });
        }
      }
      await nextTick2(resetSystem);           //todo do we need async here?? i think not?? must check with the async dispatch
    }
    return nextTick2(function () {
      printResults(results);
    });
  }
</script>

<script type="module">
  import {addEventTargetRegistry as addEventTargetRegistry1} from "./getEventListeners.js";
  import {addEventTargetRegistry as addEventTargetRegistry2} from "./getEventListeners_once.js";
  import {addEventTargetRegistry as addEventTargetRegistry3} from "./getEventListeners_once_last.js";
  import {addEventTargetRegistry} from "./getEventListeners_once_last_first.js";
  import {addEventIsStoppedScoped, addEventListenerOptionScopedUnstoppable} from "./ScopedEventListeners.js";
  import {addDispatchEventOptionAsync} from "./dispatchEventOptionAsync.js";
  import {scopedPaths} from "./computePaths.js";

  function SCOPEDPATHS() {
    window.scopedPaths = scopedPaths;
  }

  const eventSystems = [
    function NATIVE() {
      // resetSystem();
    },
    function SCOPED_STOP() {
      //todo this adding isStopped to window is not super good. We could instead add this to a test resource module passed into the test..
      window.isStopped = addEventIsStoppedScoped(Event.prototype);
      addEventListenerOptionScopedUnstoppable(EventTarget.prototype)
      //     Object.defineProperty(Event.prototype, "isScoped", {value: true}); todo test making isScoped=true by default/globally too..
    },

    function REGISTER() {
      window.getEventListeners = addEventTargetRegistry1(EventTarget.prototype);
    },

    function REGISTER_once() {
      window.getEventListeners = addEventTargetRegistry2(EventTarget.prototype);
    },

    function REGISTER_once_last() {
      window.getEventListeners = addEventTargetRegistry3(EventTarget.prototype);
    },

    function REGISTER_once_last_first() {
      window.getEventListeners = addEventTargetRegistry(EventTarget.prototype);
    },

    function SCOPED_STOP_REGISTER_once_last_first() {
      window.isStopped = addEventIsStoppedScoped(Event.prototype);
      addEventListenerOptionScopedUnstoppable(EventTarget.prototype)
      // addEventListenerOptionUnstoppable(EventTarget.prototype, Event.prototype);
      window.getEventListeners = addEventTargetRegistry(EventTarget.prototype);
    },

    function DISPATCH_REGISTER() {
      window.getEventListeners = addDispatchEventOptionAsync(EventTarget.prototype, true);
    }];

  import {testBasic} from "./unitTests/testBasic.js";
  import {dynamicTest} from "./unitTests/testDynamic.js";
  import {testRegistry} from "./unitTests/testRegistry.js";
  import {testOnce} from "./unitTests/testOnce.js";
  import {testUnstoppable, cancelBubbleTests} from "./unitTests/testUnstoppable.js";
  import {lastTest, lastErrorsTest, last2} from "./unitTests/testLast.js";
  import {firstTest, firstErrorsTest, first2} from "./unitTests/testFirst.js";
  import {testProp} from "./unitTests/testPropagation.js";
  import {testStopProp, testStopProp2} from "./unitTests/testStopPropagation.js";
  import {testIsStopped} from "./unitTests/testIsStopped.js";
  import {testScopedPaths, testComposedPath} from "./unitTests/testPaths.js";
  import {basicPropTest} from "./unitTests/testPropagationBasic.js";
  import {useCases} from "./unitTests/useCase1.js";

  (async function () {
    await runTests(eventSystems, testBasic);
    await runTests(eventSystems, dynamicTest);
    await runTests(eventSystems.filter(fun => fun.name.indexOf("REGISTER") >= 0), testRegistry);
    await runTests(eventSystems, testOnce);
    await runTests(eventSystems, testUnstoppable);
    await runTests(eventSystems, cancelBubbleTests);
    await runTests(eventSystems, lastTest);
    await runTests(eventSystems, last2);
    await runTests(eventSystems, lastErrorsTest);
    await runTests(eventSystems, firstTest);
    await runTests(eventSystems, first2);
    await runTests(eventSystems, firstErrorsTest);
    await runTests(eventSystems, testStopProp);
    await runTests(eventSystems, testStopProp2);
    // await runTests(eventSystems, testIsStopped);
    await runTests(eventSystems, testProp);
    await runTests([SCOPEDPATHS], testScopedPaths, Object.values(useCases));
    await runTests([SCOPEDPATHS], testComposedPath, Object.values(useCases));
    await runTests(eventSystems, basicPropTest, Object.values(useCases));
  })();
  //todo
  // 1. test stopPropagation thoroughly
  // 2. perform the same check outside in the dispatchEvent loop as is done inside in the scopedStop wrappers.
  //this is redundant.. we could have a wrapper method for that one..
</script>